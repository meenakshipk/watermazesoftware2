/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package wmsoftware;

import ij.io.FileSaver;
import ij.ImagePlus;
import ij.gui.OvalRoi;
import ij.gui.Plot;
import ij.gui.PlotWindow;
import ij.gui.Roi;
import ij.measure.CurveFitter;
import ij.process.FloatProcessor;
import ij.process.ImageProcessor;
import ij.plugin.filter.*;
import java.awt.Component;
import java.awt.Image;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.io.File;
import java.io.Serializable;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import static java.lang.Float.NaN;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import org.jfree.data.xy.XYSeries;

/**
 *
 * @author Meenakshi
 */
public class WMSoftwareGUI extends javax.swing.JFrame {

    private int totalMiceNo;
    private int totalTrialNo;
    private File dir;
    private DataStore[] dss;
    private Component frame;
    private double userBin;

    /**
     * Creates new form WMSoftwareGUI
     */
    public WMSoftwareGUI() {
        initComponents();
        jComboBoxTrialNo.removeAllItems();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDialog1 = new javax.swing.JDialog();
        jLabel3 = new javax.swing.JLabel();
        buttonGroupPlotGroupDataBy = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldTrials = new javax.swing.JTextField();
        jTextFieldTotalMiceNo = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jComboBoxTrialNo = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jButtonUploadFiles = new javax.swing.JButton();
        jButtonReadFiles = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabelMaps = new javax.swing.JLabel();
        jCheckBoxRDist = new javax.swing.JCheckBox();
        jCheckBoxRVel = new javax.swing.JCheckBox();
        jCheckBoxRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRVelErr = new javax.swing.JCheckBox();
        jButtonGenHMap = new javax.swing.JButton();
        jCheckBoxResTime = new javax.swing.JCheckBox();
        jLabel7 = new javax.swing.JLabel();
        jCheckBoxIndividualMouse1 = new javax.swing.JCheckBox();
        jCheckBoxAveMouse1 = new javax.swing.JCheckBox();
        jPanel3 = new javax.swing.JPanel();
        jCheckBoxRDistvRVel = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelErr = new javax.swing.JCheckBox();
        jLabelPlots = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jTextFieldUserBin = new javax.swing.JTextField();
        jButtonGenPlot = new javax.swing.JButton();
        jLabel8 = new javax.swing.JLabel();
        jCheckBoxIndividualMouse2 = new javax.swing.JCheckBox();
        jCheckBoxAveMouse2 = new javax.swing.JCheckBox();

        jDialog1.setTitle("Select files");
        jDialog1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jDialog1.setModalityType(java.awt.Dialog.ModalityType.DOCUMENT_MODAL);

        jLabel3.setText("Select files for each trial:");

        javax.swing.GroupLayout jDialog1Layout = new javax.swing.GroupLayout(jDialog1.getContentPane());
        jDialog1.getContentPane().setLayout(jDialog1Layout);
        jDialog1Layout.setHorizontalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(jLabel3)
                .addContainerGap(259, Short.MAX_VALUE))
        );
        jDialog1Layout.setVerticalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addComponent(jLabel3)
                .addContainerGap(260, Short.MAX_VALUE))
        );

        jDialog1.getAccessibleContext().setAccessibleParent(jButton1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Water Maze Software");

        jLabel1.setText("Number of mice per trial:");

        jLabel2.setText("Total number of trials:");

        jButton1.setText("Select Files");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jComboBoxTrialNo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        jLabel4.setText("Trial number:");

        jButtonUploadFiles.setText("Upload Files");
        jButtonUploadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonUploadFilesActionPerformed(evt);
            }
        });

        jButtonReadFiles.setText("Read Files");
        jButtonReadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonReadFilesActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jTextFieldTrials, javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonUploadFiles)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonReadFiles)
                        .addGap(0, 204, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextFieldTrials, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton1)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonUploadFiles)
                    .addComponent(jButtonReadFiles))
                .addContainerGap(184, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Select Files", jPanel1);

        jLabelMaps.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelMaps.setText("Maps:");

        jCheckBoxRDist.setText("R-Distance");

        jCheckBoxRVel.setText("R-Velocity");

        jCheckBoxRVelaP.setText("R-Velocity along platform");

        jCheckBoxRVelpP.setText("R-Velocity perpendicular to platform");

        jCheckBoxRVelErr.setText("R-Velocity Errors");

        jButtonGenHMap.setText("Generate Heat Maps");
        jButtonGenHMap.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGenHMapActionPerformed(evt);
            }
        });

        jCheckBoxResTime.setText("Residence Time");

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel7.setText("Output data:");

        jCheckBoxIndividualMouse1.setText("Individual mouse");

        jCheckBoxAveMouse1.setText("Average mouse");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxResTime)
                    .addComponent(jCheckBoxRVelErr)
                    .addComponent(jCheckBoxRVelpP)
                    .addComponent(jLabelMaps)
                    .addComponent(jCheckBoxRDist)
                    .addComponent(jCheckBoxRVel)
                    .addComponent(jCheckBoxRVelaP)
                    .addComponent(jButtonGenHMap)
                    .addComponent(jLabel7)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jCheckBoxIndividualMouse1)
                        .addGap(18, 18, 18)
                        .addComponent(jCheckBoxAveMouse1)))
                .addContainerGap(285, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabelMaps)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxResTime)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDist)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRVel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRVelaP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRVelpP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRVelErr)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBoxIndividualMouse1)
                    .addComponent(jCheckBoxAveMouse1))
                .addGap(7, 7, 7)
                .addComponent(jButtonGenHMap)
                .addContainerGap(70, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Generate Maps", jPanel2);

        jCheckBoxRDistvRVel.setText("R-Distance vs R-Velocity");

        jCheckBoxRDistvRVelaP.setText("R-Distance vs R-Velocity along platform");

        jCheckBoxRDistvRVelpP.setText("R-Distance vs R-Velocity perpendicular to platform");

        jCheckBoxRDistvRVelErr.setText("R-Distance vs R-Velocity Errors");

        jLabelPlots.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelPlots.setText("Plots:");

        jLabel5.setText("Enter bin width in X:");

        jTextFieldUserBin.setText("0.00");

        jButtonGenPlot.setText("Generate Plots");
        jButtonGenPlot.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGenPlotActionPerformed(evt);
            }
        });

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel8.setText("Output data:");

        jCheckBoxIndividualMouse2.setText("Individual mouse");

        jCheckBoxAveMouse2.setText("Average mouse");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelPlots)
                    .addComponent(jCheckBoxRDistvRVelErr)
                    .addComponent(jCheckBoxRDistvRVelpP)
                    .addComponent(jCheckBoxRDistvRVelaP)
                    .addComponent(jCheckBoxRDistvRVel)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jButtonGenPlot)
                    .addComponent(jLabel8)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jCheckBoxIndividualMouse2)
                        .addGap(18, 18, 18)
                        .addComponent(jCheckBoxAveMouse2)))
                .addContainerGap(242, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabelPlots)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelaP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelpP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelErr)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBoxIndividualMouse2)
                    .addComponent(jCheckBoxAveMouse2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 11, Short.MAX_VALUE)
                .addComponent(jButtonGenPlot)
                .addGap(65, 65, 65))
        );

        jTabbedPane1.addTab("Generate Plots", jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        jComboBoxTrialNo.removeAllItems();
        try {
            totalTrialNo = Integer.parseInt(jTextFieldTrials.getText());
            totalMiceNo = Integer.parseInt(jTextFieldTotalMiceNo.getText());
            if (totalTrialNo == 0 || totalMiceNo == 0) {
                JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
                return;
            }
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
        }
        //create checkbox with total trial no.
        for (int i = 0; i < totalTrialNo; i++) {
            jComboBoxTrialNo.addItem(Integer.toString(i + 1));
        }
        //create array for DataStore of all trials
        dss = new DataStore[totalTrialNo];
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButtonUploadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonUploadFilesActionPerformed
        //choose multiple files
        JFileChooser Fc = new JFileChooser();
        Fc.setMultiSelectionEnabled(true);
        //int result = Fc.showOpenDialog(this);
        Fc.showOpenDialog(this);
        //creates DataStore for selected trial no.
        int index = jComboBoxTrialNo.getSelectedIndex();
        if (totalMiceNo != Fc.getSelectedFiles().length) {
            JOptionPane.showMessageDialog(frame, "Number of files selected does not match number of mice.", "ERROR", JOptionPane.ERROR_MESSAGE);
        } else {
            dss[index] = new DataStore(totalMiceNo, Fc.getSelectedFiles());
        }
    }//GEN-LAST:event_jButtonUploadFilesActionPerformed

    private void jButtonReadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonReadFilesActionPerformed
        //reads the file and creates DataTrace for each file/mouse, in each trial
        for (int i = 0; i < dss.length; i++) {
            dss[i].readFile();
        }
        //print dialog box
        JOptionPane.showMessageDialog(frame, "Files read.", "Task completed", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_jButtonReadFilesActionPerformed

    private void jButtonGenHMapActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGenHMapActionPerformed
        if (jCheckBoxIndividualMouse1.isSelected() || jCheckBoxAveMouse1.isSelected()) {
            //BitSet for the checkboxes
            BitSet bs = new BitSet(6);

            bs.set(0, jCheckBoxResTime.isSelected());
            bs.set(1, jCheckBoxRDist.isSelected());
            bs.set(2, jCheckBoxRVel.isSelected());
            bs.set(3, jCheckBoxRVelaP.isSelected());
            bs.set(4, jCheckBoxRVelpP.isSelected());
            bs.set(5, jCheckBoxRVelErr.isSelected());

            //Select directory to store files
            JFileChooser Fc = new JFileChooser();
            Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            Fc.showOpenDialog(this);
            dir = Fc.getSelectedFile();

            Measures m = new Measures();
            Maps map = new Maps();
            ImageProcessor ip = null;

            int ds_counter = 0;
            for (DataStore ds : dss) {

                int size = ds.getTotalMice();
                for (int mouse = 0; mouse < size; mouse++) {
                    XYSeries series = (XYSeries) ds.getHMap("Position").get(mouse);
                    ArrayList<Float> RmList = new ArrayList<>();

                    ArrayList<Float> result = new ArrayList<>();
                    HashMap resultHMap = new HashMap<>();

                    //Residence time calc for frequency count of visited pixels
                    ArrayList<Integer> resultResTime = m.resTime(series);
                    //dimensions hardcoded 240*240
                    int dimX = 240;
                    int dimY = 240;
                    ImageProcessor ipResTime = new FloatProcessor(dimX, dimY);
                    float[][] arrayResTime = new float[dimX][dimY];
                    for (int Y = 0; Y < dimY; Y++) {
                        for (int X = 0; X < dimX; X++) {
                            int arrayIdx = (Y * 240) + X;
                            arrayResTime[X][Y] = resultResTime.get(arrayIdx);
                        }
                    }
                    ipResTime.setFloatArray(arrayResTime);
                    resultHMap = ds.getHMap("Residence Time") == null ? new HashMap<>() : ds.getHMap("Residence Time");
                    resultHMap.put(mouse, resultResTime);
                    ds.setHMap("Residence Time", resultHMap);

                    for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
                        String resultName = "";

                        switch (i) {
                            case 0: //residence time
//                              resultName = "Residence Time";
//                              map.show(ipResTime);
                                map.saveHeatMap("ResTime_M" + mouse, ipResTime);
                                break;

                            case 1: //rdist
                                resultName = "Distance";
                                result = m.dist(series);
                                break;

                            case 2: //rvel
                                resultName = "Velocity";
                                result = m.vel(series);
                                break;

                            case 3: //rvel along pt
                                resultName = "Velocity along Platform";
                                result = m.velComponent(series, "cos");
                                break;

                            case 4:
                                resultName = "Velocity perpendicular Platform";
                                result = m.velComponent(series, "sin");
                                break;

                            case 5:
                                resultName = "Velocity Error";
                                result = m.velErr(series);
                                break;
                        }

                        //store results in datastore's hashmaps
                        resultHMap = ds.getHMap(resultName) == null ? new HashMap<>() : ds.getHMap(resultName);
                        resultHMap.put(mouse, result);
                        ds.setHMap(resultName, resultHMap);

                        if (jCheckBoxIndividualMouse1.isSelected() && i != 0) {

                            //image generation
                            ArrayList<Float> sumValues = map.sumAcrossPixel(series, result);
                            ArrayList<Float> averagedValues = new ArrayList<>();
                            for (int ii = 0; ii < sumValues.size(); ii++) {
                                float averagedPixel;
                                if (resultResTime.get(ii) == 0) {
                                    averagedPixel = sumValues.get(ii);
                                } else {
                                    averagedPixel = sumValues.get(ii) / resultResTime.get(ii);
                                }
                                averagedValues.add(ii, averagedPixel);
                            }
                            ip = map.generateHeatMap(averagedValues);
                            ImagePlus image = new ImagePlus(resultName + "_M" + mouse + "_T" + ds_counter, ip);
//                        map.show(ip);
                            map.saveHeatMap(resultName + "_M" + mouse + "_T" + ds_counter, ip);

                            //polynomial surface fit
                            //threshold out 0 values and create an ROI in restime image
                            double minValue = 1;
                            double maxValue = ipResTime.getMax();
//                        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
                            ipResTime.setThreshold(minValue, maxValue, 3);
                            ThresholdToSelection tts = new ThresholdToSelection();
                            Roi selectionROI = tts.convert(ipResTime);
                            Rectangle bounds = selectionROI.getBounds();
//                        System.out.println("Bounding rect" + bounds);
                            image.setRoi(selectionROI);

                            //polynomial fit function - result window is NaN - WHY?
                            Polynomial_Surface_Fit psf = new Polynomial_Surface_Fit(image);
                            image = psf.run(ip);
//                        image.show();
                            //apply differential here 
                            Differentials_JB diffJB = new Differentials_JB();
                            diffJB.run2(image);
                            //then invert before finding maxima
                            ip = image.getProcessor();
                            ip.invert(); //so minima can be maxima

                            //Find maxima within the pool ROI
                            OvalRoi pool = new OvalRoi(0, 0, 240, 240);
                            //find maxima
                            MaximumFinder mf = new MaximumFinder();
                            Polygon maximas = mf.getMaxima(ip, 0.00001, true); //excludes edges
//                        System.out.println("Find Maxima: XCoord " + Arrays.toString(maximas.xpoints));
//                        System.out.println("Find Maxima: YCoord " + Arrays.toString(maximas.ypoints));
//                        System.out.println("Points: " + maximas.npoints + Arrays.toString(maximas.xpoints) + Arrays.toString(maximas.ypoints));

                            ArrayList<Float> intensity = new ArrayList<>();
                            int xb = (int) bounds.getX();
                            int yb = (int) bounds.getY();
                            for (int ii = 0; ii < maximas.npoints; ii++) {
                                int X = maximas.xpoints[ii] + xb;
                                int Y = maximas.ypoints[ii] + yb;
                                if (pool.containsPoint(X, Y)) {
                                    intensity.add(ip.getPixelValue(maximas.xpoints[ii], maximas.ypoints[ii]));
                                    float Rm = (float) Math.sqrt(Math.pow((175 - X), 2) + Math.pow((175 - Y), 2));
                                    RmList.add(Rm);
                                }
                            }

                            float max_intensity = Collections.max(intensity);
                            int index = intensity.indexOf(max_intensity);
                            float Rm = RmList.get(index);
//                        System.out.println("Rm list for all maximas UNSORTED: " + RmList);
//                        Collections.sort(RmList);
//                       System.out.println("Rm list for all maximas: " + RmList);
                            HashMap rmHMap = ds.getHMap(resultName + " Rm Map") == null ? new HashMap<>() : ds.getHMap(resultName + " Rm Map");
                            rmHMap.put(mouse, Rm);
                            ds.setHMap(resultName + " Rm Map", rmHMap);

                            //resize image to 240 by 240 dimension
                            float[][] processedArray = new float[dimX][dimY];
                            for (int Y = 0; Y < dimY; Y++) {
                                for (int X = 0; X < dimX; X++) {
                                    processedArray[X][Y] = NaN;
                                }
                            }
//                        int xb = (int) bounds.getX();  //already defined above
//                        int yb = (int) bounds.getY();  // already defined above
                            int xbmax = (int) bounds.getWidth();
                            int ybmax = (int) bounds.getHeight();
                            float[][] f = ip.getFloatArray();
                            for (int Y = 0; Y < ybmax; Y++) {
                                for (int X = 0; X < xbmax; X++) {
                                    if (pool.containsPoint(X + xb, Y + yb)) {
                                        processedArray[X + xb][Y + yb] = f[X][Y];
                                    }
                                }
                            }
                            ImageProcessor processedip = new FloatProcessor(processedArray);
                            map.saveHeatMap(resultName + "processed_M" + mouse + "_T" + ds_counter, processedip);
                        }
                        if (i == Integer.MAX_VALUE) {
                            break;
                        }
                    }
                }

                //Calculate average mouse
                if (jCheckBoxAveMouse1.isSelected()) {
                    int dimX = 240;
                    int dimY = 240;

                    //Residence time calc for frequency count of visited pixels
                    HashMap resTimeHMap = ds.getHMap("Residence Time");
                    ArrayList<Integer> sumResTime = new ArrayList<>();
                    for (int iii = 0; iii < dimX * dimY; iii++) {
                        sumResTime.add(0);
                    }
                    for (int ii = 0; ii < resTimeHMap.size(); ii++) {
                        ArrayList<Integer> resTime = (ArrayList<Integer>) resTimeHMap.get(ii);
                        for (int iii = 0; iii < resTime.size(); iii++) {
                            int avePixel = sumResTime.get(iii) + resTime.get(iii);
                            sumResTime.set(iii, avePixel);
                        }
                    }

                    ImageProcessor ipResTime = new FloatProcessor(dimX, dimY);
                    float[][] arrayResTime = new float[dimX][dimY];
                    for (int Y = 0; Y < dimY; Y++) {
                        for (int X = 0; X < dimX; X++) {
                            int arrayIdx = (Y * 240) + X;
                            arrayResTime[X][Y] = sumResTime.get(arrayIdx);
                        }
                    }
                    ipResTime.setFloatArray(arrayResTime);

                    for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
                        String resultName = "";

                        switch (i) {
                            case 0: //residence time
                                resultName = "Residence Time";
                                //save restime ave
                                map.saveHeatMap("ResTime_aveM", ipResTime);
                                break;

                            case 1: //rdist
                                resultName = "Distance";
                                break;

                            case 2: //rvel
                                resultName = "Velocity";
                                break;

                            case 3: //rvel along pt
                                resultName = "Velocity along Platform";
                                break;

                            case 4:
                                resultName = "Velocity perpendicular Platform";
                                break;

                            case 5:
                                resultName = "Velocity Error";
                                break;
                        }

                        if (i != 0) {
                            HashMap posHMap = ds.getHMap("Position");
                            HashMap resultHMap = ds.getHMap(resultName);

                            //sum measure values for mice
                            ArrayList<Float> sumValMeasures = new ArrayList<>();
                            for (int iii = 0; iii < dimX * dimY; iii++) {
                                sumValMeasures.add(0f);
                            }
                            for (int ii = 0; ii < resultHMap.size(); ii++) {
                                XYSeries series = (XYSeries) posHMap.get(ii);
                                ArrayList<Float> result = (ArrayList<Float>) resultHMap.get(ii);
                                ArrayList<Float> mValues = map.sumAcrossPixel(series, result);
                                for (int iii = 0; iii < mValues.size(); iii++) {
                                    float summedPixel = sumValMeasures.get(iii) + mValues.get(iii);
                                    sumValMeasures.set(iii, summedPixel);
                                }
                            }

                            //calculate ave mouse for measure
                            ArrayList<Float> aveMouse = new ArrayList<>();
                            for (int iii = 0; iii < sumValMeasures.size(); iii++) {
                                float averagedPixel;
                                if (sumResTime.get(iii) == 0) {
                                    averagedPixel = sumValMeasures.get(iii);
                                } else {
                                    averagedPixel = sumValMeasures.get(iii) / sumResTime.get(iii);
                                }
                                aveMouse.add(iii, averagedPixel);
                            }
                            ip = map.generateHeatMap(aveMouse);
                            map.saveHeatMap(resultName + "_AveM" + "_T" + ds_counter, ip);
                            ImagePlus image = new ImagePlus(resultName + "_AveM" + "_T" + ds_counter, ip);

                            //code to do surface fit, diff, find maxima and save the maxima
                            //polynomial surface fit
                            //threshold out 0 values and create an ROI in restime image
                            double minValue = 1;
                            double maxValue = ipResTime.getMax();
//                        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
                            ipResTime.setThreshold(minValue, maxValue, 3);
                            ThresholdToSelection tts = new ThresholdToSelection();
                            Roi selectionROI = tts.convert(ipResTime);
                            Rectangle bounds = selectionROI.getBounds();
                        System.out.println("Bounding rect" + bounds);
                            image.setRoi(selectionROI);

                            //polynomial fit function - result window is NaN - WHY?
                            Polynomial_Surface_Fit psf = new Polynomial_Surface_Fit(image);
                            image = psf.run(ip);
                            image.show();
                            //apply differential here 
                            Differentials_JB diffJB = new Differentials_JB();
                            diffJB.run2(image);
                            //then invert before finding maxima
                            ip = image.getProcessor();
                            ip.invert(); //so minima can be maxima

                            //Find maxima within the pool ROI
                            OvalRoi pool = new OvalRoi(0, 0, 240, 240);
                            //find maxima
                            MaximumFinder mf = new MaximumFinder();
                            Polygon maximas = mf.getMaxima(ip, 0.00001, true); //excludes edges
//                        System.out.println("Find Maxima: XCoord " + Arrays.toString(maximas.xpoints));
//                        System.out.println("Find Maxima: YCoord " + Arrays.toString(maximas.ypoints));
//                        System.out.println("Points: " + maximas.npoints + Arrays.toString(maximas.xpoints) + Arrays.toString(maximas.ypoints));
                            ArrayList<Float> RmList = new ArrayList<>();
                            ArrayList<Float> intensity = new ArrayList<>();
                            int xb = (int) bounds.getX();
                            int yb = (int) bounds.getY();
                            for (int ii = 0; ii < maximas.npoints; ii++) {
                                int X = maximas.xpoints[ii] + xb;
                                int Y = maximas.ypoints[ii] + yb;
                                if (pool.containsPoint(X, Y)) {
                                    intensity.add(ip.getPixelValue(maximas.xpoints[ii], maximas.ypoints[ii]));
                                    float Rm = (float) Math.sqrt(Math.pow((175 - X), 2) + Math.pow((175 - Y), 2));
                                    RmList.add(Rm);
                                }
                            }

                            float max_intensity = Collections.max(intensity);
                            int index = intensity.indexOf(max_intensity);
                            float Rm = RmList.get(index);
//                        System.out.println("Rm list for all maximas UNSORTED: " + RmList);
//                        Collections.sort(RmList);
//                       System.out.println("Rm list for all maximas: " + RmList);
                            HashMap rmHMap = ds.getHMap(resultName + " Rm Map") == null ? new HashMap<>() : ds.getHMap(resultName + " Rm Map");
                            rmHMap.put((ds.getTotalMice()), Rm);
                            ds.setHMap(resultName + " Rm Map", rmHMap);

                            //resize image to 240 by 240 dimension
                            float[][] processedArray = new float[dimX][dimY];
                            for (int Y = 0; Y < dimY; Y++) {
                                for (int X = 0; X < dimX; X++) {
                                    processedArray[X][Y] = NaN;
                                }
                            }
//                        int xb = (int) bounds.getX();  //already defined above
//                        int yb = (int) bounds.getY();  // already defined above
                            int xbmax = (int) bounds.getWidth();
                            int ybmax = (int) bounds.getHeight();
                            float[][] f = ip.getFloatArray();
                            for (int Y = 0; Y < ybmax; Y++) {
                                for (int X = 0; X < xbmax; X++) {
                                    if (pool.containsPoint(X + xb, Y + yb)) {
                                        processedArray[X + xb][Y + yb] = f[X][Y];
                                    }
                                }
                            }
                            ImageProcessor processedip = new FloatProcessor(processedArray);
                            map.saveHeatMap(resultName + "processed_AveM" + "_T" + ds_counter, processedip);
                        }
                        if (i == Integer.MAX_VALUE) {
                            break;
                        }
                    }
                }

                //Write out complete file with list of calculated Rm - should be done after average mouse is calculated
                for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
                    String resultName = "";
                    switch (i) {

                        case 1: //rdist
                            resultName = "Distance";
                            break;

                        case 2: //rvel
                            resultName = "Velocity";
                            break;

                        case 3: //rvel along pt
                            resultName = "Velocity along Platform";
                            break;

                        case 4:
                            resultName = "Velocity perpendicular Platform";
                            break;

                        case 5:
                            resultName = "Velocity Error";
                            break;
                    }
                    if (!resultName.isEmpty()) {
                        //write out file with list of calculated Rm
                        ds.writeFiles(resultName + "_RmMap_" + ds_counter, dir.getAbsolutePath(), ds.getHMap(resultName + " Rm Map"));
                    }
                    if (i == Integer.MAX_VALUE) {
                        break;
                    }
                }
                ds_counter++;
            }
            System.out.println("Button click done.");
        } else {
            JOptionPane.showMessageDialog(frame, "Please select individual mouse or average mouse.", "ERROR", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_jButtonGenHMapActionPerformed

    private void jButtonGenPlotActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGenPlotActionPerformed
        if (jCheckBoxIndividualMouse2.isSelected() || jCheckBoxAveMouse2.isSelected()) {
            BitSet bs = new BitSet(4);

            bs.set(0, jCheckBoxRDistvRVel.isSelected());
            bs.set(1, jCheckBoxRDistvRVelaP.isSelected());
            bs.set(2, jCheckBoxRDistvRVelpP.isSelected());
            bs.set(3, jCheckBoxRDistvRVelErr.isSelected());

            //bin size for binning values
            userBin = Double.parseDouble(jTextFieldUserBin.getText());

            //Select directory to store files
            JFileChooser Fc = new JFileChooser();
            Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            Fc.showOpenDialog(this);
            dir = Fc.getSelectedFile();

            Measures m = new Measures();
//        Plots p = new Plots();
            for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
                int ds_counter = 0;

                for (DataStore ds : dss) {
                    String resultName = "";
//                ArrayList<double[]> paraList = new ArrayList<>();

                    int size = ds.getTotalMice();
                    for (int mouse = 0; mouse < size; mouse++) {
                        XYSeries series = (XYSeries) ds.getHMap("Position").get(mouse);
                        HashMap resultDistHMap = ds.getHMap("Distance") == null ? new HashMap<>() : ds.getHMap("Distance");
                        ArrayList<Float> resultDist = m.dist(series);
                        resultDistHMap.put(mouse, resultDist);
                        ds.setHMap("Distance", resultDistHMap);

                        ArrayList result = new ArrayList<>();
                        HashMap resultHMap = new HashMap<>();
                        switch (i) {

                            case 0: //rvel
                                resultName = "Velocity";
                                result = m.vel(series);
                                break;

                            case 1: //rvel along pt
                                resultName = "Velocity along Platform";
                                result = m.velComponent(series, "cos");
                                break;

                            case 2:
                                resultName = "Velocity perpendicular Platform";
                                result = m.velComponent(series, "sin");
                                break;

                            case 3:
                                resultName = "Velocity Error";
                                result = m.velErr(series);
                                break;
                        }

                        resultHMap = ds.getHMap(resultName) == null ? new HashMap<>() : ds.getHMap(resultName);
                        resultHMap.put(mouse, result);
                        ds.setHMap(resultName, resultHMap);

                        if (jCheckBoxIndividualMouse2.isSelected()) {
                            XYSeries resultSeries = this.toXYSeries(resultName, resultDist, result);
                            resultSeries = this.binSeriesinX(userBin, resultSeries);
                            //first method to plot and fit to polynomial and save parameters of fit
                            ArrayList<double[]> Array = this.toArray(resultSeries);
                            double[] xData = Array.get(0);
                            double[] yData = Array.get(1);
                            CurveFitter cf = new CurveFitter(xData, yData);
                            cf.doFit(CurveFitter.POLY2);
                            double[] para = cf.getParams();
                            Plot plot = cf.getPlot();

                            //2nd method to save plot
                            plot.setXYLabels("Distance", resultName);
                            String title = "Distance vs " + resultName + ": M_" + mouse;
                            PlotWindow pw = plot.show();
                            pw.setTitle(title);
                            ImagePlus imp = plot.getImagePlus();
                            imp.setTitle(title);
//                        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + imp.getTitle() + ".tif");

                            //calculate Rm from coefficients
                            double B0 = para[0];
                            double B1 = para[1];
                            double B2 = para[2];
                            double[] Rm = new double[3];
                            double det = 48.10488 + (72 * B1);
                            double thetam1 = (9.42 + Math.sqrt(det)) / 6;
                            double thetam2 = (9.42 - Math.sqrt(det)) / 6;
                            double RmValue = (Math.pow(thetam1, 2) - (3.14 * thetam1) + 3.287) / (2 * (B2 + 1));
                            Rm[0] = thetam1;
                            Rm[1] = thetam2;
                            Rm[2] = RmValue;
//                        ArrayList<Float> RmList = new ArrayList<>();
//                        RmList.add((float) Rm[2]);
                            HashMap rmHMap = ds.getHMap(resultName + " Rm Plot") == null ? new HashMap<>() : ds.getHMap(resultName + " Rm Plot");
                            rmHMap.put(mouse, Rm[2]);
                            ds.setHMap(resultName + " Rm Plot", rmHMap);
//                        System.out.println(resultName + " Rm from fit: " + RmList);
                        }
                    }

                    //write out file with list of calculated Rm
                    ds.writeFiles(resultName + "_RmPlot_" + ds_counter, dir.getAbsolutePath(), ds.getHMap(resultName + " Rm Plot"));
                    System.out.println("End of code.");

////                //bar plot for Rm - CHECK IF VALUES ARE CORRECT
////                double[] yvalues = new double[RmList.size()];
////                for (int ii = 0; ii < RmList.size(); ii++) {
////                    yvalues[ii] = RmList.get(ii)[2];
////                }
////                Plot rmPlot = new Plot("Rm Plot: Distance vs Velocity", "Mouse", "Rm");
////                rmPlot.add("separated bar", yvalues);
////                rmPlot.show();
////
////                if (jCheckBoxAveMouse2.isSelected()) {
////                    //TO DO: check results
////                    Mouse aveM = new Mouse();
////                    aveM.setID(ds.getMiceNo());
////                    ds.setMouse(aveM);
////
////                    int dimX = 200;
////                    int dimY = 200;
////                    float sum[][] = new float[dimX][dimY];
////                    int N[][] = new int[dimX][dimY];
////                    for (int mouse = 0; mouse < size; mouse++) {
////                        HashMap resultDistHMap = ds.getHMap("Distance") == null ? new HashMap<>() : ds.getHMap("Distance");
////                        HashMap resultHMap = ds.getHMap(resultName) == null ? new HashMap<>() : ds.getHMap(resultName);
////                        ArrayList<Float> resultDist = (ArrayList<Float>) resultDistHMap.get(mouse);
////                        ArrayList<Float> result = (ArrayList<Float>) resultHMap.get(mouse);
////                        XYSeries resultSeries = this.toXYSeries(resultName, resultDist, result);
////                        resultSeries = this.binSeriesinX(userBin, resultSeries);
////                        ArrayList<double[]> Array = this.toArray(resultSeries);
////
////                    }
////
////                    float[][] aveMouseArray = new float[dimX][dimY];
////                    for (int pixY = 0; pixY < dimY; pixY++) {
////                        for (int pixX = 0; pixX < dimX; pixX++) {
////                            aveMouseArray[pixX][pixY] = sum[pixX][pixY] / N[pixX][pixY];
////                        }
////                    }
////
////                }
                    ds_counter++;
                }
                if (i == Integer.MAX_VALUE) {
                    break;
                }
            }
        } else {
            JOptionPane.showMessageDialog(frame, "Please select individual mouse or average mouse.", "ERROR", JOptionPane.ERROR_MESSAGE);
        }

        System.out.println("End of button press");
    }//GEN-LAST:event_jButtonGenPlotActionPerformed

    private XYSeries toXYSeries(String name, ArrayList<Float> ar1, ArrayList<Float> ar2) {
        XYSeries series = new XYSeries(name, true);
        for (int i = 0; i < ar1.size() && i < ar2.size(); i++) {
            series.add(ar1.get(i), ar2.get(i));
        }
        return series;
    }

    private XYSeries binSeriesinX(double binWidth, XYSeries Series) {
        XYSeries binnedData = new XYSeries(Series.getKey());
        double binStart = (double) Series.getX(0).doubleValue();
        double binEnd = binStart + binWidth;
        double halfbinWidth = binWidth / 2;
        double binCtr = binStart + halfbinWidth;
        double sum = binStart;
        int count = 1;

        for (int i = 0; i < Series.getItemCount(); i++) {

            double curX = Series.getX(i).doubleValue();
            double curY = Series.getY(i).doubleValue();

            if (binStart <= curX && curX < binEnd) {
                sum += curY;
                count++;
            } else {
                double yData = sum / count;
                binnedData.add(binCtr, sum / count);
                sum = curY;
                count = 1;
                binStart = curX;
                binCtr = binStart + halfbinWidth;
                binEnd = binStart + binWidth;
            }
        }

        return binnedData;

    }

    private ArrayList<double[]> toArray(XYSeries series) {
        ArrayList<double[]> result = new ArrayList<>();
        double[] resultX = new double[series.getItemCount()];
        double[] resultY = new double[series.getItemCount()];

        for (int C = 0; C < series.getItemCount(); C++) {
            resultX[C] = series.getX(C).doubleValue();
            resultY[C] = series.getY(C).doubleValue();
        }
        result.add(resultX);
        result.add(resultY);
        return result;
    }

    private class Measures {

        private Measures() {
        }

        private ArrayList<Integer> resTime(XYSeries series) {
            //dimensions hardcoded 240*240
            int dimX = 240;
            int dimY = 240;

            ArrayList<Integer> resTime = new ArrayList();
            for (int count = 0; count < (dimX * dimY); count++) {
                resTime.add(0);
            }
            for (int i = 0; i < series.getItemCount(); i++) {
                float XPo = series.getX(i).floatValue();
                float YPo = series.getY(i).floatValue();
                int arrayIdx = ((Math.round(YPo) * 240) + Math.round(XPo));
                resTime.set(arrayIdx, (resTime.get(arrayIdx) + 1));
            }
            return resTime;
        }

        private XYSeries corSeries(XYSeries series) {
            XYSeries seriesCorr = new XYSeries("PositionCorr", false);
            for (int i = 0; i < series.getItemCount(); i++) {
                seriesCorr.add((175 - series.getX(i).floatValue()), (175 - series.getY(i).floatValue()));
            }
            return seriesCorr;
        }

        private ArrayList<Float> dist(XYSeries series) {
            ArrayList<Float> result = new ArrayList<>();
            XYSeries seriesCorr = this.corSeries(series);
            //rdist                        
            result = this.getMeasureMagnitude(seriesCorr);
            return result;
        }

        private XYSeries delVel(XYSeries series) {
            XYSeries result = new XYSeries("delVel");
            XYSeries seriesCorr = this.corSeries(series);
            //delvel                        
            result = this.getDelMeasureMagnitude(seriesCorr);
            return result;
        }

        private ArrayList<Float> vel(XYSeries series) {
            ArrayList<Float> result = new ArrayList<>();
            XYSeries seriesCorr = this.corSeries(series);
            XYSeries delVel = this.delVel(series);
            //delvel                        
            result = this.getMeasureMagnitude(delVel);
            return result;
        }

        private ArrayList<Float> velComponent(XYSeries series, String component) {
            String comp = component;
            ArrayList<Float> result = new ArrayList<>();

            ArrayList<Float> RDist = this.dist(series);
            ArrayList<Float> RVel = this.vel(series);
            XYSeries delVel = this.delVel(series);
            XYSeries seriesCorr = this.corSeries(series);
            ArrayList<Double> ThetaVel = new ArrayList<>();
            //Calculate ThetaVel and RVelaP
            for (int k = 0; k < (series.getItemCount() - 1); k++) {
                double value = ((delVel.getX(k).floatValue() * seriesCorr.getX(k).floatValue()) + (delVel.getY(k).floatValue() * seriesCorr.getY(k).floatValue())) / (RDist.get(k) * RVel.get(k));
                ThetaVel.add(k, Math.acos(value));
                if ("cos".equals(comp)) {
                    result.add(k, (float) (RVel.get(k) * Math.cos(ThetaVel.get(k))));
                } else if ("sin".equals(comp)) {
                    result.add(k, (float) (RVel.get(k) * Math.sin(ThetaVel.get(k))));
                }
            }
            return result;
        }

        private ArrayList<Float> velErr(XYSeries series) {
            ArrayList<Float> result = new ArrayList<>();

            ArrayList<Float> RDist = this.dist(series);
            XYSeries delVel = this.delVel(series);
            XYSeries seriesCorr = this.corSeries(series);

            //RVelErr Initialise
            ArrayList<Float> XVelErr = new ArrayList<>();
            ArrayList<Float> YVelErr = new ArrayList<>();
            ArrayList<Float> Xcap = new ArrayList<>();
            ArrayList<Float> Ycap = new ArrayList<>();
            //Calculate RVelErr
            for (int k = 0; k < (series.getItemCount() - 1); k++) {
                Xcap.add(k, (seriesCorr.getX(k).floatValue() / RDist.get(k)));
                Ycap.add(k, (seriesCorr.getY(k).floatValue() / RDist.get(k)));
                XVelErr.add(k, ((delVel.getX(k).floatValue() * Xcap.get(k)) - delVel.getX(k).floatValue()));
                YVelErr.add(k, ((delVel.getY(k).floatValue() * Ycap.get(k)) - delVel.getY(k).floatValue()));
                result.add(k, this.getMeasureMagnitude(XVelErr, YVelErr).get(k));
            }
            return result;
        }

        private ArrayList<Float> getMeasureMagnitude(ArrayList<Float> X, ArrayList<Float> Y) {
            ArrayList<Float> result = new ArrayList<>();
            for (int i = 0; i < X.size() && i < Y.size(); i++) {
                result.add(i, (float) Math.sqrt(Math.pow(X.get(i), 2) + Math.pow(Y.get(i), 2)));
            }
            return result;
        }

//    private ArrayList<Float> getmeasureAngle(ArrayList<Float> X, ArrayList<Float> Y) {
//        ArrayList<Float> result = new ArrayList<>();
//        for (int mouse = 0; mouse < X.size() && mouse < Y.size(); mouse++) {
//            if (Y.get(mouse) != 0) {
//                result.add(mouse, (float) Math.atan2(Y.get(mouse), X.get(mouse))); //How to deal with x=0 error?
//            }
//        }
//        return result;
//    }
//
//    private ArrayList<Float> getDelMeasure(ArrayList<Float> M) {
//        ArrayList<Float> result = new ArrayList<>();
//        for (int mouse = 0; mouse < (M.size() - 1); mouse++) {
//            result.add(mouse, M.get(mouse) - M.get(mouse + 1));
//        }
//        return result;
//    }
        private ArrayList<Float> getMeasureMagnitude(XYSeries series) {
            ArrayList<Float> result = new ArrayList<>();
            for (int i = 0; i < series.getItemCount(); i++) {
                result.add(i, (float) Math.sqrt(Math.pow(series.getX(i).floatValue(), 2) + Math.pow(series.getY(i).floatValue(), 2)));
            }
            return result;
        }

        private ArrayList<Float> getMeasureAngle(XYSeries series) {
            ArrayList<Float> result = new ArrayList<>();
            for (int i = 0; i < series.getItemCount(); i++) {
                if ((double) series.getX(i) != 0) {
                    result.add(i, (float) Math.atan2(series.getY(i).floatValue(), series.getX(i).floatValue())); //How to deal with x=0 error?
                } else {
                    result.add(i, Float.MAX_VALUE);
                }
            }
            return result;
        }

        private XYSeries getDelMeasureMagnitude(XYSeries series) {
            XYSeries result = new XYSeries(series.getKey(), false);
            for (int i = 0; i < (series.getItemCount() - 1); i++) {
                result.add(series.getX(i).floatValue() - series.getX(i + 1).floatValue(), series.getY(i).floatValue() - series.getY(i + 1).floatValue());
            }
            return result;
        }
    }

    private class Maps {

        private Maps() {
        }

        private void show(ImageProcessor ip) {
            ImagePlus imp = new ImagePlus("", ip);
            imp.show();
        }

        private void saveHeatMap(String title, ImageProcessor ip) {
            ImagePlus imp = new ImagePlus(title, ip);
            new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + imp.getTitle() + ".tif");
        }

        private ArrayList<Float> sumAcrossPixel(XYSeries curSeries, ArrayList<Float> M) {
            //dimensions hardcoded 240*240
            int dimX = 240;
            int dimY = 240;

            ArrayList<Float> result = new ArrayList<>();
            for (int count = 0; count < (dimX * dimY); count++) {
                result.add(0f);
            }

            int size = curSeries.getItemCount() - 1;
            for (int j = 0; j < size; j++) {
                float XPo = curSeries.getX(j).floatValue();
                float YPo = curSeries.getY(j).floatValue();
                int arrayIdx = ((Math.round(YPo) * 240) + Math.round(XPo));
                result.set(arrayIdx, (result.get(arrayIdx) + M.get(j)));
            }
            return result;
        }

        private ImageProcessor generateHeatMap(ArrayList<Float> measure) {
            //dimensions hardcoded 240*240
            int dimX = 240;
            int dimY = 240;
            int width = dimX;
            int height = dimY;
            ImageProcessor ip = new FloatProcessor(width, height);
            float[][] image = new float[dimX][dimY];
            for (int Y = 0; Y < dimY; Y++) {
                for (int X = 0; X < dimX; X++) {
                    int arrayIdx = (Y * 240) + X;
                    image[X][Y] = measure.get(arrayIdx);
                }
            }
            ip.setFloatArray(image);
            return ip;
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new WMSoftwareGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupPlotGroupDataBy;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButtonGenHMap;
    private javax.swing.JButton jButtonGenPlot;
    private javax.swing.JButton jButtonReadFiles;
    private javax.swing.JButton jButtonUploadFiles;
    private javax.swing.JCheckBox jCheckBoxAveMouse1;
    private javax.swing.JCheckBox jCheckBoxAveMouse2;
    private javax.swing.JCheckBox jCheckBoxIndividualMouse1;
    private javax.swing.JCheckBox jCheckBoxIndividualMouse2;
    private javax.swing.JCheckBox jCheckBoxRDist;
    private javax.swing.JCheckBox jCheckBoxRDistvRVel;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelErr;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelaP;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelpP;
    private javax.swing.JCheckBox jCheckBoxRVel;
    private javax.swing.JCheckBox jCheckBoxRVelErr;
    private javax.swing.JCheckBox jCheckBoxRVelaP;
    private javax.swing.JCheckBox jCheckBoxRVelpP;
    private javax.swing.JCheckBox jCheckBoxResTime;
    private javax.swing.JComboBox<String> jComboBoxTrialNo;
    private javax.swing.JDialog jDialog1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabelMaps;
    private javax.swing.JLabel jLabelPlots;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextField jTextFieldTotalMiceNo;
    private javax.swing.JTextField jTextFieldTrials;
    private javax.swing.JTextField jTextFieldUserBin;
    // End of variables declaration//GEN-END:variables
}
